---
layout: default
---

# 6.4 内部类  
+ `内部类(InnerClass)`是定义在另一个类中的类
+ 使用内部类的原因:
    - 内部类方法可以访问该类定义所在的作用域中的数据,包括私有数据  
    - 内部类可以对同一个包中的其他类隐藏起来  
    - 当想要定义一个回调函数且不想编写大量代码时,使用`匿名(anonymous)`内部类比较便捷  

## 6.4.1 使用内部类访问对象状态  
+ 内部类的对象总有一个隐式引用,它指向了创建它的外部类对象.这个引用在内部类的定义中是不可见的    

## 6.4.2 内部类的特殊语法规则  
+ 外围类引用内部类的正规语法:`OuterClass.this`表示外围引用(OutClass指代的是外围类)  
+ `outerObject.new InnerClass(constructor parameters)` 更加明确地编写内部对象的构造器  
+ 内部类中声明的所有静态域都必须是final.  
+ 内部类`不能有static方法`  

## 6.4.3 内部类是否有用、必要和安全  

## 6.4.4 局部内部类   
+ 局部类不能用public或private访问说明符进行声明.它的作用域被限定在这个局部类的块中  
+ 局部类对外部世界可以完全隐藏  

## 6.4.5 由外部方法访问变量  
+ 内部类不仅能够访问包含它们的外部类,还可以访问局部变量  
    - 这些局部变量必须事实上为final.一旦赋值就绝不会改变  

## 6.4.6 匿名内部类  
+ `匿名内部类(anonymous inner class)`: 只有一个对象的内部类  

    ```
    new SuperType(construction parameters){
        inner class methods and data
    }
    ```
+ 匿名类不能有构造器.取而代之的是,将构造器参数传递给父类构造器  
    - 尤其在内部类实现接口的时候,不能有任何构造参数
    ```
    new InterfaceType(){
        methods and data
    }
    ```

## 6.4.7 静态内部类  
+ 有时候,使用内部类`只是为了把一个类隐藏在另外一个类的内部`,并不需要外围类对象.为此,可以将内部类声明为`static`,以便取消产生的引用  
+ 在内部类不需要访问外围类对象时,应该使用静态内部类  
+ 与常规内部类不同,静态内部类可以有静态域和方法  
+ 声明在接口中的内部类自动转换成`static`和`public`类  
[返回](/index.md)