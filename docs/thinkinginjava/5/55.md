---
layout: default
---

# 5.5 清理:终结处理和垃圾回收  

## 导航  

[**返回**](../menu)  

1. [5.5.1 finalize()用途何在](#551-finalize()用途何在)  
2. [5.5.2 你必须实施清理](#552-你必须实施清理)  
3. [5.5.3 终结条件](#553-终结条件)  
4. [5.5.4 垃圾回收器如何工作](#554-垃圾回收器如何工作)  

- Java里的对象**并非总是被垃圾回收**  
  1. 对象可能不被垃圾回收  
  2. 垃圾回收并不等于"析构"  
  3. 垃圾回收只和内存有关

## 5.5.1 finalize()用途何在

- 使用垃圾回收器的唯一原因**是为了回收程序不再使用的内存**  
- 无论对象是如何创建的,垃圾回收器都会负责释放对象所占用的所有内存  
- 之所以要有finalize(),是由于在分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法  
- 不要过多使用finalize()  
    >终结函数无法预料,常常是危险的,总之是多余的  

## 5.5.2 你必须实施清理  

- 如果希望进行除释放存储空间之外的清理工作,还是得明确调用某个恰当的Java方法.
- 如果JVM并未面临内存耗尽的情况,它是不会浪费时间去执行垃圾回收以恢复内存的.  

## 5.5.3 终结条件  

- 当对某个对象不再感兴趣，也就是它可以被清理了,这个对象应该处于某种状态,使它占用的内存可以被安全地释放  
- 只要对象中存在没有被适当清理的部分,程序就存在很隐晦的缺陷,**finalize()可以用来最终发现这种情况————尽管它并不总是会被调用**  

```java
//: initialization/TerminationCondition.java
// Using finalize() to detect an object that
// hasn't been properly clean up
class Book{
    boolean checkOut=false;
    Book(boolean checkOut){ this.checkOut=checkOut;}
    void checkIn(){ this.checkOut=false;}

    protected void finalize(){
        if(checkOut)  System.out.println("Error:Check Out");
        // Normally，you'll also do this:
        // super.finalize();  //Call the base-class version
    }
}

public class TerminationCondition{
    public static void main(String[] args) {
        Book novel=new Book(true);
        //Proper cleanup
        novel.checkIn();
        //Drop the reference, forget to clean up
        new Book(true);
        //Fource garbage coolecion & finalization
        System.gc();
    }
}/*Output:
Error:Check Out
 *///:~
```

## 5.5.4 垃圾回收器如何工作  

- **引用计数**方法  
  - 实现方式:  每个对象都含有一个引用计数器.当有引用接至对象时,引用计数加1.当引用离开 作用域或被置为null，引用计数减1.  
  - 问题: 如果对象之间存在循环引用,可能会出现 _对象应该被回收,但引用计数却不为零_ 的情况.对于垃圾回收器而言,定位这样的交互自引用的对象组所需的工作量极大.
  - 使用场景: 常用来**说明垃圾收集的工作方式**,但并未应用于任何一种JVM实现中.  
  - 特点: **简单,但速度很慢**  

- **更快速**的垃圾回收技术
  - 思想:  **对任何"活的"对象,一定能最终追溯到其存活在堆栈或静态存储区之中的引用**.这个引用链条可能会穿过数个对象层次.  
  - 实现:  
    - step 1: 从堆栈和静态存储区开始,遍历所有引用,就能找到所有"活"的对象.  
    - step 2: 对于发现的每个引用,必须追踪它所引用的对象,然后是这个对象所包含的所有引用,如此反复进行,直到**根源于堆栈和静态存储区的引用**所形成的网络全部被访问为止.访问过的对象必须都是"活"的  
    - 注意:  这解决了**交互自引用的对象组**的问题  

- **停止-复制(_stop-and-copy_)**  
  - 一种 _自适应_ 的垃圾回收技术  
  - 思想:  
    - 先暂停程序运行,然后将所有存活的对象从当前堆复制到另一个堆,没有被复制的都是垃圾  
    - 当对象被复制到新堆是,他们是一个挨着一个的,所以新堆保持紧凑排列,然后可以前述方法简单直接地分配内存空间了  
  - 注意点：  
    - 当把对象从一处搬到另一处时,**所有指向它的那些引用都必须修正**  